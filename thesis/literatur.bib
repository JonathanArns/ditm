% Encoding: UTF-8
@article{challenges_and_options,
	author = {Beschastnikh, Ivan and Wang, Patty and Brun, Yuriy and Ernst,
	          Michael D,},
	title = {Debugging Distributed Systems: Challenges and Options for
	         Validation and Debugging},
	year = {2016},
	issue_date = {March-April 2016},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {14},
	number = {2},
	issn = {1542-7730},
	doi = {10.1145/2927299.2940294},
	abstract = {Distributed systems pose unique challenges for software
	            developers. Reasoning about concurrent activities of system nodes
	            and even understanding the system’s communication topology can be
	            difficult. A standard approach to gaining insight into system
	            activity is to analyze system logs. Unfortunately, this can be a
	            tedious and complex process. This article looks at several key
	            features and debugging challenges that differentiate distributed
	            systems from other kinds of software. The article presents
	            several promising tools and ongoing research to help resolve
	            these challenges.},
	journal = {Queue},
	month = mar,
	pages = {91–110},
	numpages = {20},
}

@article{why_is_random_testing_effective,
	author = {Majumdar, Rupak and Niksic, Filip},
	title = {Why is Random Testing Effective for Partition Tolerance Bugs?},
	year = {2017},
	issue_date = {January 2018},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {2},
	number = {POPL},
	doi = {10.1145/3158134},
	abstract = {Random testing has proven to be an effective way to catch bugs
	            in distributed systems in the presence of network partition
	            faults. This is surprising, as the space of potentially faulty
	            executions is enormous, and the bugs depend on a subtle interplay
	            between sequences of operations and faults. We provide a
	            theoretical justification of the effectiveness of random testing
	            in this context. First, we show a general construction, using the
	            probabilistic method from combinatorics, that shows that whenever
	            a random test covers a fixed coverage goal with sufficiently high
	            probability, a small randomly-chosen set of tests achieves full
	            coverage with high probability. In particular, we show that our
	            construction can give test sets exponentially smaller than
	            systematic enumeration. Second, based on an empirical study of
	            many bugs found by random testing in production distributed
	            systems, we introduce notions of test coverage relating to
	            network partition faults which are effective in finding bugs.
	            Finally, we show using combinatorial arguments that for these
	            notions of test coverage we introduce, we can find a lower bound
	            on the probability that a random test covers a given goal. Our
	            general construction then explains why random testing tools
	            achieve good coverage---and hence, find bugs---quickly. While we
	            formulate our results in terms of network partition faults, our
	            construction provides a step towards rigorous analysis of random
	            testing algorithms, and can be applicable in other scenarios.},
	journal = {Proc. ACM Program. Lang.},
	month = dec,
	articleno = {46},
	numpages = {24},
	keywords = {probabilistic method, distributed systems, network partition
	            faults, random testing},
}

@article{abstracting_the_geniuses,
	author = {Alvaro, Peter and Tymon, Severine},
	title = {Abstracting the Geniuses Away from Failure Testing},
	year = {2017},
	issue_date = {January 2018},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {61},
	number = {1},
	issn = {0001-0782},
	doi = {10.1145/3152483},
	abstract = {Ordinary users need tools that automate the selection of
	            custom-tailored faults to inject.},
	journal = {Commun. ACM},
	month = dec,
	pages = {54–61},
	numpages = {8},
}

@online{go_transport_docs,
	author = {Google},
	title = {Golang Standard Library Documentation: net/http},
	date = {2021-09-09},
	url = {https://pkg.go.dev/net/http#Transport},
	urldate = {2021-09-27},
}

@misc{go_retry_commit,
	author = {Gentry, Blake and Fitzpatrick, Brad},
	title = {net/http: retry idempotent HTTP reqs on dead reused conns},
	date = {2015-01-22},
	howpublished = {In: Golang VCS},
	publisher = {Google},
	url = {https://go-review.googlesource.com/c/go/+/3210/9//COMMIT_MSG#1},
	urldate = {2021-09-27},
}

@online{jepsen_analyses,
	author = {Kingsbury, Kyle},
	title = {Jepsen Analyses},
	date = {2017-02-16},
	url = {https://jepsen.io/analyses},
	urldate = {2021-09-29},
}

@inproceedings{analysis_of_network_partition_failures,
	author = {Ahmed Alquraan and Hatem Takruri and Mohammed Alfatafta and Samer
	          Al-Kiswany},
	title = {An Analysis of Network-Partitioning Failures in Cloud Systems},
	booktitle = {13th {USENIX} Symposium on Operating Systems Design and
	             Implementation ({OSDI} 18)},
	year = {2018},
	isbn = {978-1-939133-08-3},
	address = {Carlsbad, CA},
	pages = {51--68},
	publisher = {{USENIX} Association},
	month = oct,
}

@article{chaos_engineering,
	author = {Basiri, Ali and Behnam, Niosha and de Rooij, Ruud and Hochstein,
	          Lorin and Kosewski, Luke and Reynolds, Justin and Rosenthal, Casey},
	journal = {IEEE Software},
	title = {Chaos Engineering},
	year = {2016},
	volume = {33},
	number = {3},
	pages = {35-41},
	doi = {10.1109/MS.2016.60},
}

@inproceedings{distributed_replay_debugging_1997,
	author = {Neri, Daniel and Pautet, Laurent and Tardieu, Samuel},
	title = {Debugging Distributed Applications with Replay Capabilities},
	year = {1997},
	isbn = {0897919815},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	doi = {10.1145/269629.269649},
	booktitle = {Proceedings of the Conference on TRI-Ada '97},
	pages = {189–195},
	numpages = {7},
	location = {St. Louis, Missouri, USA},
	series = {TRI-Ada '97},
}

@mastersthesis{failify_masters_thesis,
	title = {Towards a Library for Deterministic Failure Testing of Distributed
	         Systems THESIS},
	author = {Balalaie, Armin},
	year = {2020},
	school = {UNIVERSITY OF CALIFORNIA, IRVINE},
}

@article{oddity_graphical_debugger,
	title = {A Graphical Interactive Debugger for Distributed Systems},
	author = {Doug Woos and Zachary Tatlock and Michael D. Ernst and Thomas E.
	          Anderson},
	journal = {ArXiv},
	year = {2018},
	volume = {abs/1806.05300},
}

@article{ShiViz_visual_debugger,
	author = {Beschastnikh, Ivan and Wang, Patty and Brun, Yuriy and Ernst,
	          Michael D.},
	title = {Debugging Distributed Systems},
	year = {2016},
	issue_date = {August 2016},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {59},
	number = {8},
	issn = {0001-0782},
	doi = {10.1145/2909480},
	abstract = {ShiViz is a new distributed system debugging visualization tool.
	            },
	journal = {Commun. ACM},
	month = jul,
	pages = {32–37},
	numpages = {6},
}

@inproceedings{gotcha_interactive_debugger,
	author = {Achar, Rohan and Dawn, Pritha and Lopes, Cristina V.},
	title = {GoTcha: An Interactive Debugger for GoT-Based Distributed Systems},
	year = {2019},
	isbn = {9781450369954},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	doi = {10.1145/3359591.3359733},
	abstract = {Debugging distributed systems is hard. Most of the techniques
	            that have been developed for debugging such systems use either
	            extensive model checking, or postmortem analysis of logs and
	            traces. Interactive debugging is typically a tool that is only
	            effective in single threaded and single process applications, and
	            is rarely applied to distributed systems. While the live
	            observation of state changes using interactive debuggers is
	            effective, it comes with a host of problems in distributed
	            scenarios. In this paper, we discuss the requirements an
	            interactive debugger for distributed systems should meet, the
	            role the underlying distributed model plays in facilitating the
	            debugger, and the implementation of our interactive debugger:
	            GoTcha. GoTcha is a browser based interactive debugger for
	            distributed systems built on the Global Object Tracker (GoT)
	            programming model. We show how the GoT model facilitates the
	            debugger, and the features that the debugger can offer. We also
	            demonstrate a typical debugging workflow.},
	booktitle = {Proceedings of the 2019 ACM SIGPLAN International Symposium on
	             New Ideas, New Paradigms, and Reflections on Programming and
	             Software},
	pages = {94–110},
	numpages = {17},
	keywords = {Interactive Debugging, Debugging Distributed Systems},
	location = {Athens, Greece},
	series = {Onward! 2019},
}

@inproceedings{log_analysis_at_google,
	author = {Xu, Wei and Huang, Ling and Fox, Armando and Patterson, David and
	          Jordan, Michael},
	title = {Experience Mining Google's Production Console Logs},
	year = {2010},
	publisher = {USENIX Association},
	address = {USA},
	abstract = {We describe our early experience in applying our console log
	            mining techniques [19, 20] to logs from production Google systems
	            with thousands of nodes. This data set is five orders of
	            magnitude in size and contains almost 20 times as many messages
	            types as the Hadoop data set we used in [19]. It also has many
	            properties that are unique to large scale production deployments
	            (e.g., the system stays on for several months and multiple
	            versions of the software can run concurrently). Our early
	            experience shows that our techniques, including source code based
	            log parsing, state and sequence based feature creation and
	            problem detection, work well on this production data set. We also
	            discuss our experience in using our log parser to assist the log
	            sanitization.},
	booktitle = {Proceedings of the 2010 Workshop on Managing Systems via Log
	             Analysis and Machine Learning Techniques},
	pages = {5},
	numpages = {1},
	location = {Vancouver, BC, Canada},
	series = {SLAML'10},
}

@techreport{dapper_tracing,
	title = {Dapper, a Large-Scale Distributed Systems Tracing Infrastructure},
	author = {Benjamin H. Sigelman and Luiz André Barroso and Mike Burrows and
	          Pat Stephenson and Manoj Plakal and Donald Beaver and Saul Jaspan
	          and Chandan Shanbhag},
	year = {2010},
	URL = {https://research.google.com/archive/papers/dapper-2010-1.pdf},
	institution = {Google, Inc.},
}

@misc{so_you_want_to_trace,
	author = {Sambasivan, Raja and Fonseca, Rodrigo and Shafer, Ilari and Ganger
	          , Gregory},
	year = {2014},
	month = {04},
	title = {So, you want to trace your distributed system? Key design insights
	         from years of practical experience},
	howpublished = {Parallel Data Laboratory, Carnegie Mellon University},
}

@inproceedings{magpie_tracing,
	title = {Using Magpie for request extraction and workload modelling.},
	author = {Barham, Paul and Donnelly, Austin and Isaacs, Rebecca and Mortier,
	          Richard},
	booktitle = {Proceedings of the 6th {USENIX} Symposium on Operating Systems
	             Desing and Implementation ({OSDI} 04)},
	volume = {4},
	pages = {18--18},
	year = {2004},
}

@inproceedings{distributed_replay_debugging_2006,
	title = {Replay debugging for distributed applications},
	author = {Geels, Dennis Michael and Altekar, Gautam and Shenker, Scott and
	          Stoica, Ion},
	year = {2006},
	school = {University of California, Berkeley},
	booktitle = {Proceedings of the 2006 {USENIX} Annual Technical Conference},
	pages = {289-300},
}

@inproceedings{debugAR_AR_debugger,
	author = {Reipschl\"{a}ger, Patrick and Ozkan, Burcu Kulahcioglu and Mathur,
	          Aman Shankar and Gumhold, Stefan and Majumdar, Rupak and Dachselt,
	          Raimund},
	title = {DebugAR: Mixed Dimensional Displays for Immersive Debugging of
	         Distributed Systems},
	year = {2018},
	isbn = {9781450356213},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	doi = {10.1145/3170427.3188679},
	abstract = {Distributed systems are very complex and in case of errors hard
	            to debug. The high number of messages with non deterministic
	            delivery timings, as well as message losses, data corruption and
	            node crashes cannot be efficiently analyzed with traditional GUI
	            tools. We propose to use immersive technologies in a
	            multi-display environment to tackle these shortcomings. Our
	            DebugAR approach shows a representation of the current systems
	            state, message provenance, and the lifetime of participating
	            nodes and offers layouting techniques. By providing a screen that
	            shows a traditional text-log, we bridge the gap to conventional
	            tools. Additionally, we propose an interactive 3D visualization
	            of the message flow, combining an interactive tabletop with
	            augmented reality using a head-mounted display. We are confident
	            that our proposed solution can not only be used to analyze
	            distributed system, but also for other time-dependent networks.},
	booktitle = {Extended Abstracts of the 2018 CHI Conference on Human Factors
	             in Computing Systems},
	pages = {1–6},
	numpages = {6},
	keywords = {3d visualizations, multi-display environments, debugging,
	            distributed systems, interactive surfaces, augmented reality},
	location = {Montreal QC, Canada},
	series = {CHI EA '18},
}

@inproceedings{normal_record_and_replay,
	author = {Honarmand, Nima and Torrellas, Josep},
	booktitle = {2014 ACM/IEEE 41st International Symposium on Computer
	             Architecture (ISCA)},
	title = {Replay debugging: Leveraging record and replay for program
	         debugging},
	year = {2014},
	volume = {},
	number = {},
	pages = {455-456},
	doi = {10.1109/ISCA.2014.6853229},
}

@inproceedings{oddity_usage_in_education,
	author = {Michael, Ellis and Woos, Doug and Anderson, Thomas and Ernst,
	          Michael D. and Tatlock, Zachary},
	title = {Teaching Rigorous Distributed Systems With Efficient Model Checking
	         },
	year = {2019},
	isbn = {9781450362818},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	doi = {10.1145/3302424.3303947},
	abstract = {Writing correct distributed systems code is difficult,
	            especially for novice programmers. The inherent asynchrony and
	            need for fault-tolerance make errors almost inevitable.
	            Industrial-strength testing and model checking have been shown to
	            be effective at uncovering bugs, but they come at a cost --- in
	            both time and effort --- that is far beyond what students can
	            afford. To address this, we have developed an efficient model
	            checking framework and visual debugger for distributed systems,
	            with the goal of helping students find and fix bugs in near
	            real-time. We identify two novel techniques for reducing the
	            search state space to more efficiently find bugs in student
	            implementations. We report our experiences using these tools to
	            help over two hundred students build a correct, linearizable,
	            fault-tolerant, dynamically-sharded key--value store.},
	booktitle = {Proceedings of the Fourteenth EuroSys Conference 2019},
	articleno = {32},
	numpages = {15},
	keywords = {model checking, distributed systems, education},
	location = {Dresden, Germany},
	series = {EuroSys '19},
}

@article{ShiViz_usage_study,
	author = {Beschastnikh, Ivan and Liu, Perry and Xing, Albert and Wang, Patty
	          and Brun, Yuriy and Ernst, Michael D.},
	title = {Visualizing Distributed System Executions},
	year = {2020},
	issue_date = {April 2020},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {29},
	number = {2},
	issn = {1049-331X},
	doi = {10.1145/3375633},
	journal = {ACM Trans. Softw. Eng. Methodol.},
	month = mar,
	articleno = {9},
	numpages = {38},
	keywords = {program comprehension, log analysis, Distributed systems},
}

@inproceedings{raft_original_paper,
	author = {Diego Ongaro and John Ousterhout},
	title = {In Search of an Understandable Consensus Algorithm},
	booktitle = {2014 {USENIX} Annual Technical Conference ({USENIX} {ATC} 14)},
	year = {2014},
	isbn = {978-1-931971-10-2},
	address = {Philadelphia, PA},
	pages = {305--319},
	publisher = {{USENIX} Association},
	month = jun,
}

@online{jepsen_github,
	author = {Kyle Kingsbury et. al.},
	url = {https://github.com/jepsen-io/jepsen},
	urldate = {2021-10-24},
	title = {Jepsen},
	publisher = {Github},
}

@online{jepsen_mongo_analysis,
	author = {Kyle Kingsbury},
	url = {https://aphyr.com/posts/322-jepsen-mongodb-stale-reads},
	urldate = {2021-10-25},
	date = {2015-04-20},
	title = {Jepsen: MongoDB stale reads},
}

@online{jepsen_redis_raft,
	author = {Kyle Kingsbury},
	url = {https://jepsen.io/analyses/redis-raft-1b3fbf6},
	urldate = {2021-11-04},
	date = {2020-06-23},
	title = {Jepsen: Redis-Raft 1b3fbf6},
}

@inproceedings{d3s_predicate_checker,
	title = {D3S: Debugging Deployed Distributed Systems},
	author = {Xuezheng Liu and Zhenyu Guo and Xi Wang and Feibo Chen and
	          Xiaochen Lian and Jian Tang and Ming Wu and M. Frans Kaashoek and
	          Zheng Zhang},
	booktitle = {NSDI},
	year = {2008},
}

@inproceedings{failify_paper,
	author = {Balalaie, Armin and Jones, James A.},
	title = {Towards a Library for Deterministic Failure Testing of Distributed
	         Systems},
	year = {2019},
	isbn = {9781450369732},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	doi = {10.1145/3357223.3366026},
	booktitle = {Proceedings of the ACM Symposium on Cloud Computing},
	pages = {486},
	numpages = {1},
	location = {Santa Cruz, CA, USA},
	series = {SoCC '19},
}

@inproceedings{simple_testing_can_prevent,
	author = {Ding Yuan and Yu Luo and Xin Zhuang and Guilherme Renna Rodrigues
	          and Xu Zhao and Yongle Zhang and Pranay U. Jain and Michael Stumm},
	title = {Simple Testing Can Prevent Most Critical Failures: An Analysis of
	         Production Failures in Distributed Data-Intensive Systems},
	booktitle = {11th {USENIX} Symposium on Operating Systems Design and
	             Implementation ({OSDI} 14)},
	year = {2014},
	isbn = { 978-1-931971-16-4},
	address = {Broomfield, CO},
	pages = {249--265},
	publisher = {{USENIX} Association},
	month = oct,
}

@inproceedings{why_does_cloud_stop_computing,
	author = {Gunawi, Haryadi S. and Hao, Mingzhe and Suminto, Riza O. and
	          Laksono, Agung and Satria, Anang D. and Adityatama, Jeffry and
	          Eliazar, Kurnia J.},
	title = {Why Does the Cloud Stop Computing? Lessons from Hundreds of Service
	         Outages},
	year = {2016},
	isbn = {9781450345255},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	doi = {10.1145/2987550.2987583},
	abstract = {We conducted a cloud outage study (COS) of 32 popular Internet
	            services. We analyzed 1247 headline news and public post-mortem
	            reports that detail 597 unplanned outages that occurred within a
	            7-year span from 2009 to 2015. We analyzed outage duration, root
	            causes, impacts, and fix procedures. This study reveals the
	            broader availability landscape of modern cloud services and
	            provides answers to why outages still take place even with
	            pervasive redundancies.},
	booktitle = {Proceedings of the Seventh ACM Symposium on Cloud Computing},
	pages = {1–16},
	numpages = {16},
	location = {Santa Clara, CA, USA},
	series = {SoCC '16},
}

@book{distributed_systems_concepts_and_design,
	title = {Distributed systems: concepts and design},
	author = {Coulouris, George F and Dollimore, Jean and Kindberg, Tim and
	          Blair, Gordon},
	year = {2012},
	publisher = {Pearson Education, Inc.},
	location = {Boston, USA},
	isbn = {978-0-13-214301-1},
}

@article{brief_introduction_to_distributed_systems,
	title = {A brief introduction to distributed systems},
	author = {van Steen, Maarten and Tanenbaum, Andrew S},
	journal = {Computing},
	volume = {98},
	number = {10},
	pages = {967--1009},
	year = {2016},
	publisher = {Springer},
}

@book{distributed_systems_book,
	title = {Distributed systems},
	author = {Van Steen, Maarten and Tanenbaum, Andrew S},
	year = {2017},
	publisher = {Leiden, The Netherlands},
}

@article{cloud_virtualization,
	author = {Shukur, Hanan and Zeebaree, Subhi and Zebari, Rizgar and Zeebaree,
	          Qader and Ahmed, Omar and Salih, Azar},
	year = {2020},
	month = {06},
	pages = {98-105},
	title = {Cloud Computing Virtualization of Resources Allocation for
	         Distributed Systems},
	volume = {1},
	journal = {Journal of Applied Science and Technology Trends},
	doi = {10.38094/jastt1331},
}

@article{the_network_is_reliable,
	title = {The network is reliable: An informal survey of real-world
	         communications failures},
	author = {Bailis, Peter and Kingsbury, Kyle},
	journal = {Queue},
	volume = {12},
	number = {7},
	pages = {20--32},
	year = {2014},
	publisher = {ACM New York, NY, USA},
}

@article{linearizability_paper,
	author = {Herlihy, Maurice P. and Wing, Jeannette M.},
	title = {Linearizability: A Correctness Condition for Concurrent Objects},
	year = {1990},
	issue_date = {July 1990},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {12},
	number = {3},
	issn = {0164-0925},
	doi = {10.1145/78969.78972},
	abstract = {A concurrent object is a data object shared by concurrent
	            processes. Linearizability is a correctness condition for
	            concurrent objects that exploits the semantics of abstract data
	            types. It permits a high degree of concurrency, yet it permits
	            programmers to specify and reason about concurrent objects using
	            known techniques from the sequential domain. Linearizability
	            provides the illusion that each operation applied by concurrent
	            processes takes effect instantaneously at some point between its
	            invocation and its response, implying that the meaning of a
	            concurrent object's operations can be given by pre- and
	            post-conditions. This paper defines linearizability, compares it
	            to other correctness conditions, presents and demonstrates a
	            method for proving the correctness of implementations, and shows
	            how to reason about concurrent objects, given they are
	            linearizable.},
	journal = {ACM Trans. Program. Lang. Syst.},
	month = jul,
	pages = {463–492},
	numpages = {30},
}

@inproceedings{cap_brewer,
	title = {Towards robust distributed systems},
	author = {Brewer, Eric A},
	booktitle = {PODC},
	volume = {7},
	number = {10.1145},
	pages = {343477--343502},
	year = {2000},
	organization = {Portland, OR},
}

@article{perspectives_on_cap,
	author = {Gilbert, Seth and Lynch, Nancy},
	journal = {Computer},
	title = {Perspectives on the CAP Theorem},
	year = {2012},
	volume = {45},
	number = {2},
	pages = {30-36},
	doi = {10.1109/MC.2011.389},
}

@inproceedings{mugshot_js_replay_proxy,
	author = {Mickens, James and Elson, Jeremy and Howell, Jon},
	title = {Mugshot: Deterministic Capture and Replay for Javascript
	         Applications},
	year = {2010},
	publisher = {USENIX Association},
	address = {USA},
	booktitle = {Proceedings of the 7th USENIX Conference on Networked Systems
	             Design and Implementation},
	pages = {11},
	numpages = {1},
	location = {San Jose, California},
	series = {NSDI'10},
}

@inproceedings{mahimahi_http_replay,
	author = {Ravi Netravali and Anirudh Sivaraman and Somak Das and Ameesh
	          Goyal and Keith Winstein and James Mickens and Hari Balakrishnan},
	title = {Mahimahi: Accurate Record-and-Replay for {HTTP}},
	booktitle = {2015 {USENIX} Annual Technical Conference ({USENIX} {ATC} 15)},
	year = {2015},
	isbn = {978-1-931971-225},
	address = {Santa Clara, CA},
	pages = {417--429},
	publisher = {{USENIX} Association},
	month = jul,
}

@inproceedings{performace_replay_testing,
	author = {Bertolino, Antonia and De Angelis, Guglielmo and Sabetta, Antonino
	          },
	booktitle = {2008 23rd IEEE/ACM International Conference on Automated
	             Software Engineering},
	title = {VCR: Virtual Capture and Replay for Performance Testing},
	year = {2008},
	pages = {399-402},
	doi = {10.1109/ASE.2008.58},
}

@phdthesis{distributed_consensus,
	author = {Heidi Howard},
	title = {Distributed consensus revisited},
	publisher = {Apollo - University of Cambridge Repository},
	year = {2019},
	doi = {10.17863/CAM.38840},
}
